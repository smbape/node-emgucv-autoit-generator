//----------------------------------------------------------------------------
//
//  Copyright (C) 2004-2021 by EMGU Corporation. All rights reserved.
//
//  Vector of PointF
//
//  This file is automatically generated, do not modify.
//----------------------------------------------------------------------------


#pragma once
#ifndef EMGU_VECTOR_PointF_H
#define EMGU_VECTOR_PointF_H

#include "vectors_c.h"

#if 1



//----------------------------------------------------------------------------
//
//  Vector of PointF
//
//----------------------------------------------------------------------------
CVAPI(std::vector< cv::Point2f >*) VectorOfPointFCreate();

CVAPI(std::vector< cv::Point2f >*) VectorOfPointFCreateSize(int size);

CVAPI(int) VectorOfPointFGetSize(std::vector< cv::Point2f >* v);

CVAPI(void) VectorOfPointFPush(std::vector< cv::Point2f >* v, cv::Point2f* value);

CVAPI(void) VectorOfPointFPushMulti(std::vector< cv::Point2f >* v, cv::Point2f* values, int count);

CVAPI(void) VectorOfPointFPushVector(std::vector< cv::Point2f >* v, std::vector< cv::Point2f >* other);

CVAPI(void) VectorOfPointFClear(std::vector< cv::Point2f >* v);

CVAPI(void) VectorOfPointFRelease(std::vector< cv::Point2f >** v);

CVAPI(void) VectorOfPointFCopyData(std::vector< cv::Point2f >* v,  cv::Point2f* data);

CVAPI(cv::Point2f*) VectorOfPointFGetStartAddress(std::vector< cv::Point2f >* v);

CVAPI(void*) VectorOfPointFGetEndAddress(std::vector< cv::Point2f >* v);

CVAPI(void) VectorOfPointFGetItem(std::vector<  cv::Point2f >* vec, int index,  cv::Point2f* element);

CVAPI(void) VectorOfPointFGetItemPtr(std::vector<  cv::Point2f >* vec, int index,  cv::Point2f** element);

#if true
CVAPI(cv::_InputArray*) cveInputArrayFromVectorOfPointF(std::vector< cv::Point2f >* vec);

CVAPI(cv::_OutputArray*) cveOutputArrayFromVectorOfPointF(std::vector< cv::Point2f >* vec);

CVAPI(cv::_InputOutputArray*) cveInputOutputArrayFromVectorOfPointF(std::vector< cv::Point2f >* vec);
#endif

CVAPI(int) VectorOfPointFSizeOfItemInBytes();

#else

static inline CV_NORETURN void throw_no_vector() { CV_Error(cv::Error::StsBadFunc, "The library is compiled without VectorOfPointF support"); }

CVAPI(void*) VectorOfPointFCreate();

CVAPI(void*) VectorOfPointFCreateSize(int size);

CVAPI(int) VectorOfPointFGetSize(void* v);

CVAPI(void) VectorOfPointFPush(void* v, void* value);

CVAPI(void) VectorOfPointFPushMulti(void* v, void* values, int count);

CVAPI(void) VectorOfPointFPushVector(void* v, void* other);

CVAPI(void) VectorOfPointFClear(void* v);

CVAPI(void) VectorOfPointFRelease(void** v);

CVAPI(void) VectorOfPointFCopyData(void* v,  void* data);

CVAPI(void*) VectorOfPointFGetStartAddress(void* v);

CVAPI(void) VectorOfPointFGetItem(void* vec, int index, void* element);

CVAPI(void) VectorOfPointFGetItemPtr(void* vec, int index, void** element);

#if true
CVAPI(cv::_InputArray*) cveInputArrayFromVectorOfPointF(void* vec);

CVAPI(cv::_OutputArray*) cveOutputArrayFromVectorOfPointF(void* vec);

CVAPI(cv::_InputOutputArray*) cveInputOutputArrayFromVectorOfPointF(void* vec);
#endif

CVAPI(int) VectorOfPointFSizeOfItemInBytes();
#endif


#endif
